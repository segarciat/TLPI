# Exercise 49-3

Write programs to verify that the `SIGBUS` and `SIGSEGV` signals are delivered in circumstances described
in Section 49.4.3.

## Solution

As discussed in Section 49.4.3, these signals may be generated by the kernel whenever a process creates
a file memory mapping and it references an invalid memory address. Specifically:

- If the size requested by the process exceeds the file's size to the extent that at least an extra
page is allocated beyond the file, then referencing this area results in a `SIGBUS`.

- If the process references a region beyond the size of the allocated memory region, the kernel
delivers a `SIGSEGV`.

To demonstrate this, I created an empty temporary file and a file mapping for it. I created a
memory region whose size is precisely the system page size, as returned by `sysconf(_SC_PAGESIZE)`.
Since the file is empty, any reference will result in a signal as explained above. First I referenced
the first byte in the region, which resulted in `SIGBUS`; then, I referenced to one byte past the
end of the region, which resulted in a `SIGSEGV`. I established a signal handler, but as explained
in Section 22.4, return from the signal handler resulted in the faulting instruction being retried,
so these hardware-generated signals continued to be raised. To break out this loop, I used `sigsetjmp`
and `siglongjmp`.

```bash
gcc mmap_signals.c
./a.out
```

The outptu was:

```
./a.out: Page Size: 4096
Attempting to memory region beyond the empty temporary file...
Attempting to write beyond the end of the file...
Signals caught:
	SIGBUS : 1
	SIGSEGV: 1
```
